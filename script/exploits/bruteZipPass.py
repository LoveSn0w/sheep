#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import zipfile
import sys
import optparse
import threading
import time
from lib.core.data import paths, logger, th

readme = {
    "zname": "zip file name",
    "fdict": "dictionary file name",
    "th": "threads, default is 10"
}

defaults = {
    "th": 10
}

def byLineReader(file):
	"""read file by line"""
	try:
		f = open(file)
	except Exception as e:
		logger.warning('Open file error %s' % e)
		sys.exit()
	line = f.readline()
	while line:
		yield line
		line = f.readline()
	f.close()
	yield None
			

def extractFile(zFile, password, zname):
	"""check this pass"""
	try:
		zFile.extractall(pwd=password)
		logger.success('Found password %s' % password)
		exploitsPath = os.path.join(paths.OUTPUT_PATH, 'exploits')
		if not os.path.isdir(exploitsPath):
			try:
				os.makedirs(exploitsPath)
				logger.info("Using '%s' as the exploits output directory" % exploitsPath)
			except Exception, e:
				logger.warning("Create exploits output directory '%s' failed! %s" % (exploitsPath, e))
		#Create a directory by current time
		today = time.strftime("%Y-%m-%d")
		todayPath = os.path.join(exploitsPath, "%s-%s.txt" % (today, zname))
		fh = open(todayPath, 'wb+')
		fh.write(password)
		fh.close()
		sys.exit()
	except:
		pass

def run(arg):
	"""Run the main function"""
	zname = arg["zname"]
	fdict = arg["fdict"]
	th = arg["th"]

	logger.info("zip password Brute Force Praparing.")
	znamePath =  os.path.join(paths.DATA_PATH, zname)
	zFile = zipfile.ZipFile(znamePath)
	logger.info("%s zipname(s) loaded." % zname)
	
	fdictPath =  os.path.join(paths.DATA_PATH, fdict)
	read = byLineReader(fdictPath)
	logger.info("%s password(s) loaded." % fdict)
	
	logger.info("Brute Force Is Starting.......")
	while True:
		if threading.activeCount() <= th:
			try:
				line = read.next()
				if line == None:
					break
				password = line.strip('\n')
				t = threading.Thread(target=extractFile, args=(zFile, password, zname))
				t.start()
				print password
			except Exception as e:
				logger.warning('Error! %s' % e)
				continue
		else:
			time.sleep(0.1)
		
	while threading.activeCount() > 1:
		time.sleep(0.1)
	return
